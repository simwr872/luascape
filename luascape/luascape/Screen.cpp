#include "Screen.h"
#include <iostream>

// Logic to initialize our static map and array. Character
// data is generated by GetCharacter() return values.
const COLORREF Screen::colors[] = {
	RGB(248, 213, 107),	// Some items orange tint
	RGB(255, 152, 31),	// Withdrawing bank items
	RGB(255, 255, 255), // White
	RGB(0, 255, 255),	// Cyan, eg. Trees
	RGB(255, 255, 0),	// Yellow, npc/fishing spot
	RGB(184, 209, 209)	// Blueish white, items in bag
};
const std::map<char, long long> Screen::chars = Screen::GenerateMap();
std::map<char, long long> Screen::GenerateMap() {
	// Characters 1IlTij, area within >> are saved. The rest
	// is used to verify clashing characters. This way any
	// character can be stored within 63 bits.
	//   xx    xxxx   xx   xxxxxx
	//  xxx     xx    xx     xx
	//   xx     xx    xx     xx
	//>  xx     xx    xx     xx     xx   xx
	//   xx     xx    xx     xx
	//   xx     xx    xx     xx     xx   xx
	//   xx     xx    xx     xx     xx   xx
	//   xx     xx    xx     xx     xx   xx
	//   xx     xx    xx     xx     xx   xx
	//> xxxx   xxxx   xx     xx     xx   xx
	//                                   xx

	// 1 = I
	// T = l
	// i = j
	// r next to t will join and produce mutant character
	std::map<char, long long> chars;
	chars['a'] = 0b0000000000000000000000111110011111101001010100101011111100110100;
	chars['b'] = 0b0000000000000000000000011110011111101000010100001011111111111111;
	chars['c'] = 0b0000000000000000000000000000001001001000010100001011111100111100;
	chars['d'] = 0b0000000000000000000000111111111111111000010100001011111100111100;
	chars['e'] = 0b0000000000000000000000101110010111101010010101001011111100111100;
	chars['f'] = 0b0000000000000000000000000000100000010001000111111111111110001000;
	chars['g'] = 0b0000000000000000000000111110011111101000010100001011111100111100;
	chars['h'] = 0b0000000000000000000000111110011111100000010000001011111111111111;
	chars['i'] = 0b0000000000000000000000000000000000000000000000000011111011111101;
	chars['j'] = 0b0000000000000000000000000000000000000000000000000011111011111101;
	chars['k'] = 0b0000000000000000000000100000011000100110110001110011111111111111;
	chars['l'] = 0b0000000000000000000000000000000000000000000000000011111111111111;
	chars['m'] = 0b0000000011111001111110000001011111001111110000001011111101111110;
	chars['n'] = 0b0000000000000000000000111110011111100000010000001011111101111110;
	chars['o'] = 0b0000000000000000000000011110011111101000010100001011111100111100;
	chars['p'] = 0b0000000000000000000000011110011111101000010100001011111101111100;
	chars['q'] = 0b0000000000000000000000111110011111101000010110011001111000011000;
	chars['r'] = 0b0000000000000000000000000000000000100000010000010011111101111110;
	chars['s'] = 0b0000000000000000000000011001011110101001010100101010011101000100;
	chars['t'] = 0b0000000000000000000000000000010000001000010111111101111110000010;
	chars['u'] = 0b0000000000000000000000111111011111101000000100000011111100111110;
	chars['v'] = 0b0000000000000000000000000011000111101111000111100000111100000110;
	chars['w'] = 0b0000000000000000111110111111001100000011000011000011111100111110;
	chars['x'] = 0b0000000000000000000000100001011101100111100011110011101101000010;
	chars['y'] = 0b0000000000000000000000111111011111100100000010000001111100011110;
	chars['z'] = 0b0000000000000000000000100001010001101001110101101011100101100010;


	chars['A'] = 0b0000000000000001111111111111100000100000010000001011111111111111;
	chars['B'] = 0b0000000000000000000000011110111111111000010100001011111111111111;
	chars['C'] = 0b0000000000000000000000010000011000001000000100000011111110111111;
	chars['D'] = 0b0000000000000000000000011111111111111000000100000011111111111111;
	chars['E'] = 0b0000000000000000000000100000010000001000010100001011111111111111;
	chars['F'] = 0b0000000000000000000000000000000000000000010000001011111111111111;
	chars['G'] = 0b0000000000000000000000011110011111001000100100000011111110111111;
	chars['H'] = 0b0000000000000000000000111111111111110000010000001011111111111111;
	chars['I'] = 0b0000000000000000000000000000000000001000000111111111111111000000;
	chars['J'] = 0b0000000000000000000000011111111111111000000100000011000000100000;
	chars['K'] = 0b0000000000000001100000111000000110010001111000011011111111111111;
	chars['L'] = 0b0000000000000000000000100000010000001000000100000011111111111111;
	chars['M'] = 0b0111111111111110000001000001100001110000011000000111111111111111;
	chars['N'] = 0b0000000000000001111111111111100111000000111000000111111111111111;
	chars['O'] = 0b0000000000000000111111111111110000001000000100000011111110111111;
	chars['P'] = 0b0000000000000000000000000001100001110000100000010011111111111111;
	chars['Q'] = 0b0000000010000001011111011111111100001010000100000011111110111111;
	chars['R'] = 0b0000000000000000000000111101111111110000100000010011111111111111;
	chars['S'] = 0b0000000000000000000000011110011111101000110100001111000110100001;
	chars['T'] = 0b0000000000000000000000000000000000000000000000000011111111111111;
	chars['U'] = 0b0000000000000000000000011111111111111000000100000011111110111111;
	chars['V'] = 0b0000000000000000000000000001100111111111100111110000111110000011;
	chars['W'] = 0b0000000000011110111111110000011111101111110110000001111110001111;
	//X
	chars['Y'] = 0b0000000000000000000000000001100001111111110111111000001110000011;
	chars['Z'] = 0b0000000000000000000000100000010000011000011100111011111001110000;

	chars['0'] = 0b0000000000000000000000001111101111111100000110000001111110011111;
	chars['1'] = 0b0000000000000000000000000000000000001000000111111111111111000000;
	chars['2'] = 0b0000000000000000000000100000110000111000010100011011111001111000;
	chars['3'] = 0b0000000000000000000000011110111111111000010100001011000000100000;
	chars['4'] = 0b0000000000000000010000111111111111110010000001001100111110011100;
	chars['5'] = 0b0000000000000000000000011111011111111000001100000111000010100001;
	chars['6'] = 0b0000000000000000000000011110011111101000010100001011111110111111;
	chars['7'] = 0b0000000000000000000000000000000000000000011000011111111101111000;
	chars['8'] = 0b0000000000000000000000011110111111111000010100001011111110111101;
	chars['9'] = 0b0000000000000000000000000111101111111110100100010000001110000011;

	chars['-'] = 0b0000000000000000000000000010000001000000100000010000001000000100;
	chars['/'] = 0b0000000000000000000000000000000000000000001000111111111101110000;
	chars['('] = 0b0000000000000000000000000000000000000000000100000011111110111111;
	chars[')'] = 0b0000000000000000000000000000000000000000000011111111111111000000;
	return chars;
}

//
//   FUNCTION: Color(const BYTE* bitPointer, const int x,
//						const int y, const int width)
//
//   PURPOSE:  Returns the color of a certain pixel.
//
COLORREF Screen::Color(const BYTE* bitPointer, const int x, const int y, const int width) {
	int index	= y * width + x;
	int blue	= (int) bitPointer[index * 4 + 0];
	int green	= (int) bitPointer[index * 4 + 1];
	int red		= (int) bitPointer[index * 4 + 2];
	return RGB(red, green, blue);
}

//
//   FUNCTION: Match(const COLORREF& color)
//
//   PURPOSE:  Determine if a color is the one we're looking for.
//
bool Screen::Match(const COLORREF& color) {
	for (int i = 0; i < sizeof(colors) / sizeof(*colors); i++) {
		if (colors[i] == color) return true;
	}
	return false;
}

//
//   FUNCTION: NextCharacter(const BYTE* bitPointer, int& _x,
//								const int _y, const int width)
//
//   PURPOSE:  Returns true if there are more characters. Also
//			   increases x value to the start of it.
//
bool Screen::NextCharacter(const BYTE* bitPointer, int& _x, const int _y, const int width) {
	// We check to CHAR_WIDTH (inclusive) to make
	// sure we are no longer reading characters.
	for (int x = _x; x < _x + CHAR_WIDTH + 1; x++) {
		for (int y = _y; y < _y + CHAR_HEIGHT; y++) {
			// If the color at this coordinate matches a color
			// in our list - update X and return true.
			if (Match(Color(bitPointer, x, y, width))) {
				_x = x;
				return true;
			}
		}
	}
	return false;
}

//
//   FUNCTION: GetCharacter(const BYTE* bitPointer, int& _x,
//								const int _y, const int width)
//
//   PURPOSE:  Reads and returns the character.
//
long long Screen::GetCharacter(const BYTE* bitPointer, int& _x, const int _y, const int width) {
	// Initialize long long to set all bits
	// to 0. Found is used to determine if 
	// we read until the space (that is the
	// space between every character).
	long long c = 0;
	bool found = false;
	for (int x = _x; x < _x + CHAR_WIDTH; x++) {
		for (int y = _y; y < _y + CHAR_HEIGHT; y++) {
			// If the color at this coordinate gives a match
			// we set the corresponding bit in the long long.
			if (Match(Color(bitPointer, x, y, width))) {
				c |= 1ULL << ((x - _x)*CHAR_HEIGHT + (y - _y));
				found = true;
			}
		}
		// If we traversed one column of pixels and
		// didn't find any matching colors - we are
		// done reading this character and currently
		// reading in a space.
		if (!found) {
			_x = x;
			return c;
		}
		found = false;
	}
	// We only come here if we read a character
	// that is exactly CHAR_WIDTH wide
	_x += CHAR_WIDTH;
	return c;
}

//
//   FUNCTION: SolveClash(const BYTE* bitPointer, const int x,
//							const char c, const int width)
//
//   PURPOSE:  Differentiates character who will return as same.
//
//   COMMENTS:
//
//        Currently only j+i, T+l and 1+I matches as the same
//        character. Usually just reading one set pixel can
//        differentiate between the two.
//
char Screen::SolveClash(const BYTE* bitPointer, const int x, const char c, const int width) {
	if (c == 'j' || c == 'i') {
		if (Match(Color(bitPointer, x - 1, 10, width))) return 'j';
		return 'i';
	} else if (c == 'T' || c == 'l') {
		if (Match(Color(bitPointer, x, 0, width))) return 'T';
		return 'l';
	} else if (c == '1' || c == 'I') {
		if (Match(Color(bitPointer, x - 1, 0, width))) return 'I';
		return '1';
	} else {
		return c;
	}
}

//
//   FUNCTION: IdentifyCharacter(const BYTE* bitPointer, const int x,
//									const long long c, const int width)
//
//   PURPOSE:  Identifies a long long as a char.
//
char Screen::IdentifyCharacter(const BYTE* bitPointer, const int x, const long long c, const int width) {
	for (std::map<char, long long>::const_iterator i = chars.begin(); i != chars.end(); i++) {
		if ((i->second ^ c) == 0) {
			return SolveClash(bitPointer, x, i->first, width);
		}
	}
	// Should't really come here but if we read
	// an unknown character. There is a special
	// case where lowercase r + t join to produce
	// a character that is 10 in width - and such
	// cannot be stored with our method. We have
	// to provide a solution to this special case.
	long long mutantR = 0b0100001011111110111111000001000000100000010000010011111101111110;
	long long mutantT = 0b0000000000000000000000000000000000000000000000000000000001000000;
	if ((c ^ mutantR) == 0) return 'r';
	if ((c ^ mutantT) == 0) return 't';
	return '.';
}

//
//   FUNCTION: ReadHover()
//
//   PURPOSE:  Reads the RuneScape clients top-left text (hover-text).
//
//   COMMENTS:
//
//        Hovertext never change color or position or size. We can
//        easily read it by capturing a 500x11 area in the top left
//        corner. Characters can actually be 9x15 in size but to
//        save space and speed the crucial parts of a character can
//        be stored in a 9x7 space (63 bits). The reason to capture
//        11 pixels is to handle the few clashes that occur. This is
//        i,j & 1,I & T,l at the moment.
//
std::string Screen::ReadHover() {
	int w = 500;
	int h = 11;
	int offx = 6;
	int offy = 7;
	// The text is a little bit offset from the top
	// left corner (6, 7)
	BYTE* bitPointer = (BYTE*) malloc(4 * w*h);
	CaptureArea(bitPointer, offx, offy, w, h);

	std::string s = "";
	int x = 0, ox = 0;
	// We start scanning for characters 3 pixels
	// below our start point - since this is where
	// the critical information lies. The 3 pixels
	// skipped, aswell as the 1 pixel skipped at
	// the bottom is used to identify clashing
	// characters.
	while (NextCharacter(bitPointer, x, 3, w)) {
		if (x - ox >= 4) s += ' ';
		long long c = GetCharacter(bitPointer, x, 3, w);
		s += IdentifyCharacter(bitPointer, x, c, w);
		ox = x;
	}
	delete bitPointer;

	return s;
}

//
//   FUNCTION: CaptureArea(BYTE* bp, const int x, const int y, const int w, const int h)
//
//   PURPOSE:  Captures a part of the RuneScape client.
//
//   COMMENTS:
//
//        A bytepointer must be passed into this function
//        and its memory MUST already be allocated!
//
void Screen::CaptureArea(BYTE* bp, const int x, const int y, const int w, const int h) {
	int imgSize = 4 * w*h;

	// Height is inverted because of the way bitmaps are
	// stored. A more conventional top-left origin is
	// preferred instead of bitmaps bottom-left.
	BITMAPINFO bitmap;
	bitmap.bmiHeader.biSize			= sizeof(bitmap.bmiHeader);
	bitmap.bmiHeader.biWidth		= w;
	bitmap.bmiHeader.biHeight		= -h;
	bitmap.bmiHeader.biPlanes		= 1;
	bitmap.bmiHeader.biBitCount		= 32;
	bitmap.bmiHeader.biCompression	= BI_RGB;
	bitmap.bmiHeader.biSizeImage	= imgSize;
	bitmap.bmiHeader.biClrUsed		= 0;
	bitmap.bmiHeader.biClrImportant = 0;

	// Fetch the RuneScape client device context and
	// create another one compatible with it. We must
	// not occupy the context for too long. (blocking)
	HDC deviceContext = GetDC(client);
	HDC deviceContextCopy = CreateCompatibleDC(deviceContext);

	BYTE* bitPointer;

	HBITMAP hBitmap = CreateDIBSection(deviceContextCopy, &bitmap, DIB_RGB_COLORS, (void**) &bitPointer, NULL, NULL);
	SelectObject(deviceContextCopy, hBitmap);
	// Top left text is offset by some set pixels.
	BitBlt(deviceContextCopy, 0, 0, w, h, deviceContext, x, y, SRCCOPY);

	// Immediatly release RuneScape's device context.
	ReleaseDC(client, deviceContext);
	DeleteObject(hBitmap);

	// Copy to our bitpointer
	memcpy(bp, bitPointer, imgSize);

	// Delete any context we created.
	DeleteDC(deviceContextCopy);
}


Screen::Screen(const HWND _client) {
	client = _client;
}